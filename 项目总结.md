ntlr 
hl.g  文法文件 -- 语法树的构造文件
基本语法 :
    节点 ^ 前面节点作为根节点
    节点 ! 忽略该节点
    名字 : 是对其语法的解释说明(描述)
    (   )* 表示括号内容可出现零次或多次
    (   )+ 表示括号内容可出现一次或多洗
     句子 -> 句子 表示该句子本来的样子 重映射到 语法树中的样子  
     ^(句子1, 句子二, 句子三) 括号中的首个句子 为根节点 后边依次为子节点  

运行操作 :

源码(.g文件) 进过编译 (antlr)  生成对应的语法树 
代码执行 : java -jar ./antlr-3.4-complete.jar  ./ (文件名).g  

代码解释:
生成的.tokens 中定义了 想关的 宏 如 ID = 5  用于 case ID 的判定

getChild(tree, chile_num); getChild方法 第一个参数为语法树第二个参数为第几个子树

ExprTreeEvaluator 类 (定义的是作用域类)
首先用map映射 表示类型的定义
 run方法中 的this指针 指向的是 ExprTreeEvaluator 类, 用this指针可表示为当前作用域
 next* 代表是 父作用域   

 运行流程 在该作用域找该变量 若未找到去父作用域中找 以次递归.
 代码详情;
 实战项目流程:
    添加作用域及除法运算


实战项目流程:

    添加作用域及除法运算
    第一步 构思新功能
     第二步 完成.g文件的语法定义 及相关的树型结构 java命令编译
     第三步 (代码完成) ExprTreeEvaluator::run 方法中完成相关 类型的解析操作

功能完善:
作用域的添加 :
    第一步:构造作用域(.g文件中 prog为程序的解释入口)
    第二步 完成.g文件 增加新的头结点 其余为子节点(block 作用域) (java命令进行检查正确性)
    代码详情 :
        def_stmt : DEF def_id (','! def_id)* ';'!;
        def_id : ID ^(ASSIGN! expr)?; ?表示可有可无.
        DEF : 'def';
    第三步: 代码完成 
    未定义错误解决
    重复定义的冲突解决
    赋值语句冲突解决
    内部作用域赋值外部值为改变 
    问题类型
    {
        def a ;
        {
            a = 10;
        }
        print a;
    }
if 语法的增加
    第一步 .g文件
        添加f_expr
        : IF^ '('! condition_expr ')'! stmt ( (ELSE) => ELSE! stmt  )?
        ;
        IF为根节点 condition_expr stmt stmt  为二三四子树 
        condition_expr // 条件控制语句
            : andExpr (OR^ andExpr)*  // 与运算高于或运算
            ;
        andExpr
            : cmp_atom (AND^ cmp_atom)*
            ;
         cmp_atom
            : cond_atom ((GT^ | LITTLE^ | EQ^ | GE^ | LE^ | NE^) cond_atom)?
            ;
        cond_atom
            : expr
            ;
    第二步  代码实现
       思路解析:
        若果 complete.jar 为ture 就执行第二颗子树
        如果 第二颗子树为ture 不执行 下一个stmt
        如果 第二颗子树为false 则执行stmt

代码复习 
  完成代码的详细文档, 对代码进行归纳总结;
  一步 视频的复习 代码的补全;
  二步 每个.g 文件的语法树和程序中用到的语法树了熟于心
  三步 学习代码的功能设计和代码的运行逻辑
  预计时间 2天


实现调试模块


一步 构建.g文件中相关的语法树

二步 进行相关功能的实现

三步 进行代码调试, 内存的检查.

预计时间 


封装与与实现解释器程序
 抽象语法树 及相关方法  ASTree.h
 作用域类的封装  parameters.h 
 .cc 文件实现思路 
 首先检查是否已存在 或者 节点是否为空 若是 就报错
 其次 若找到 变量定义 就会进行赋值 否则返回到父作用域


 IValue通用类型借口的设计
 指向本类的指针
 IValu相关代码实现
 运行环境的编写


 工厂类 每个树的节点类型是不一样, 用不同的工厂生产相对应的类, 在进行执行
 运行环境类
 工厂类
 主要功能类
 语法树的工厂类
 主要功能类  纯虚函数 run方法 通过相对应的子类 获得相关功能的结果
 生产干活类的相关工厂
 返回树的当前值
 构建当前节点所对应的工厂
 获取节点的值

 获得其节点的值
 定义转换字符串类 
 接受转换字符串类的对象 并调用visit访问
 工厂模式 访问者模式
 主管输出的类
 主管四则运算的类
 主管作用域的类
// 获取相对应的值
//运行环境
//初始化工厂


用责任链模式初始化树相应节点对应的工厂
初始化工厂
判断从工厂是否可用 该出用了责任链模式
负责挂相对应的工厂
供派生类组成链表
责任链模式: 判断当前是否可用不可用返回真假
判断三种类型是否可用
单例模式:
因为整个工厂成一条责任链
单例模式 附属生成的成员方法
//单例模式头结点 以及板块的的静态属性
//以下三个方法为责任链模式
//单例模式 三个节点 为 printFactory ExprFactory BockFactory
//处理不了的节点及输出报错信息 不能处理的节点


//运算符重载及报错信息检查
//设置为纯虚函数 即为子类进行继承
//转换为字符串的访问者模式
//值得操作父类
//整形操作的类 继承值操作类
//浮点型操作的类 继承值操作类
//字符串操作的类 继承值操作类
//各种类型的操作
//指向函数类型的指针
//字符串相关换行符等操作
// 字符串转移字符
std::String ConverStringToCString(string &temp)方法的实现
完成任务 3/4
新增运算 ++ ^


一般步骤
master-> handle->factory

//条件表达式解析 
第一步
//type.h 增加 isTrue  和 isFalse 虚函数方法判断条件是否成立 及实现
第二步
//在各种int/string/floatvalue中增加相关的继承
第三步
在handler.h 责任链模式中增加相对应的条件控制类 conditionmaster 并添加相应的工厂
class ControlFactoryHandler : public FactoryHandler {
    public :
        virtual bool is_valid(ASTree &);
        virtual void do_factory(ASTree &);

    private:
        static ControlFactory *factory;

};
第四步
在master.h中 添加
在工厂中添加相对应的生产的节点信息
class ControlFactory : public IMaster::IFactory {
            virtual IMaster *create(ASTree &, PParameter );
};
第五步
handler.cc中实现 该工厂的初始化
 ControlFactory *ControlFactoryHandler::factory = new ControlFactory();
初始化工厂的全局变量
第六步
handle.cc中实现 将工厂挂到树的节点操作
void ConditionFactoryHandler::do_factory(ASTree &tree) {
            tree.factory = factory;
            return ;
        
}
第七步 
添加责任链所能处理类型的判断方法
bool ConditionFactoryHandler::is_valid(ASTree &tree) {
    switch (tree.type()) {
                    case OR:
                    case GE:
                    case GT:
                    case LE:
                    case LITTLE:
                    case EQ:
                    case NE:
                    case AND: return true;
                    default : return false;     
    }
            return false;
}
第八步
实现master.cc中的 run方法
SIValue ConditionMaster::run() {
    switch (tree.type()) {
        case OR: {
                            SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                            if (a->isTrue()) return haizei::True_val;
                            SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                            if (b->isTrue()) return haizei::True_val;
                            return haizei::False_val;
                        
        }
        case AND: {
                            SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                            if (a->isFalse()) return haizei::False_val;
                            SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                            if (b->isTrue()) return haizei::True_val;
                            return haizei::False_val;
                        
        } 
        case GE: {
                            SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                            SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                            if ((*a) >= (*b)) return haizei::True_val;
                            return haizei::False_val;
                        
        }
        case GT: {
                            SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                            SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                            if ((*a) > (*b)) return haizei::True_val;
                            return haizei::False_val;
                        
        }
        case LE: {
                            SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                            SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                            if ((*a) <= (*b)) return haizei::True_val;
                            return haizei::False_val;
                        
        }
        case LITTLE: {
                            SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                            SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                            if ((*a) < (*b)) return haizei::True_val;
                            return haizei::False_val;
                        
        }
        case EQ: {
                            SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                            SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                            if ((*a) == (*b)) return haizei::True_val;
                            return haizei::False_val;
                        
        }
case NE: {
                    SIValue a = RunTimeEnv::GetValue(tree.at(0), p);
                    SIValue b = RunTimeEnv::GetValue(tree.at(1), p);
                    if ((*a) != (*b)) return haizei::True_val;
                    return haizei::False_val;
                
}
default : {
                    throw std::runtime_error("tree type is not condition!");
                
}
        
    }
            return haizei::False_val;
            
}
//初始化相对应的 true 和false 的值 以及controlmaster的构造函数 
static SIntValue null_val = std::make_shared<IntValue>(0);
static SIntValue True_val = std::make_shared<IntValue>(1);
static SIntValue False_val = std::make_shared<IntValue>(0);
而后实现IValue类型的运算符重载

//类型运算符重载
运算的左值
判断是否与左值匹配 第二个参数为抛出异常
增加有整形浮点型字符串型的 加减等运算操作和比较运算符的访问者

for循环的控制表示为 for关键字为根节点 子节点依次为init  condition  do(执行的操作) 和stmt(相关的代码块)  
执行流程 第一步初始化 第二部进行条件判断 第三步执行相关代码块 第四步进行相关条件的变化 一直到不成立为止(运行逻辑)

haizei_master 中 相关代码实现 
while 的代码逻辑  while关键字为根节点 子节点为 condition(条件控制语句) stmt(和代码执行逻辑)
for()存在的bug inti 不可为空  修改hl.g文件 设置空节点 


fo在实现过程中 需要新添加一个作用域 作用域使用完成后就用p->next() 回到相应的父作用域
这里的实现跟block 是一样的 
注  这里存在着代码块的内存释放bug 原本的那个作用域并没有得到释放只是返回到了父作用域
导致内存的泄露问题

内存泄漏主要是  IValue 中的智能指针的修改 可以在不用的时候进行指针的自动销毁

parameter 中智能指针类的修改 可以使的不用的指针自己销毁

break 子句相关功能的实现 
第一步 实现hl.g文件中的相关语法树的构造

每个表达式转变成相对应的状态 用状态机进行连接
例 a = 3 + 6 1号状态
    b = a * 3 + 5; 2号状态
    c = b 3号状态
    状态机的表示 1 -> 2 -> 3
    状态机基础


    for 和 while的相关修改操作如上所示


    if 和 if_else 的相关操作如上
    代码相对应的dfa的流程图

    block 首先新增节点 接着是if的语句 再是block节点的减少
    if 语句的执行 是 首先增加一个虚拟头结点 根据判断条件不同分为两部分 结束时也为一个虚拟节点  然后再接后边的 部分
   

   haizei_runtime.cc 中 新添加 DFA program(tree); 以及他的运行 program.run()方法
   
  
  两种类型的结构 一个是分叉的结构 一个是连接的结构
  next()方法 进行下一个节点的返回 (分支节点 和 连接节点)
  按照节点的功能进行继承节点的区分
  表达式节点  ExprDFANode
  后续有一个节点
  后续有两个节点
  功能类节点 
  block 增加节点
  block 减少节点
   相关方法的实现为执行完本节点返回的下一个节点
   for循环的作用域 用 blockbegin代替 消除 用blockend代替
  
  DFA的默认构造函数  初始化tree 和head tail 的值都为空地址
  IDFANode 中 vector<IDFANode *>child 存储相关的孩子节点
  build 方法是 采用递归方式实现的 判断每个节点的类型 和相关类型在语法书中的构造形式实现
  树
  NopeDFANode 表示一个没有作用的节点 用于 for 正确和不正确的 汇总节点
  build 中 if的表示  
    相关if语句的实现 0 为if的关键字 1 为条件2 为if的执行逻辑 
    else 为第三个else的执行逻辑
    case if 的逻辑 表示存好头尾节点 建立相对应的状态机 如果个数为三就表示有else的情况否则就从一号状态 指向结尾状
    while 状态机 while 有两条边 一个是condition  另一个是 stmt(执行框)
    首先头部和尾部进行相对应的初始化
    temp 为临时节点 存的是 stmt代码段 其新树的节点进行更新  第二种情况也就是 while不成立(ret->head->at(1)) 指向结束
    dfa 状态机我么实现的顺序解释
    树形结构 转换为 dfa 结构们

    if中添加的break状态机
    在dfa.h中用的栈 记录的是状态机中 离break最近的 break 所跳的节点
    while 中 的尾部节点 
    for 中的尾部节点

    for 循环长的样子 for为根节点 子树分别是 init condition do stmt 
    BreakDFANode 节点 不一定为做末尾的节点 所以 定义了BreakDFANode 新节点 进行相关的处理
    pos 记录的是相关作用域的类别
    为了支持作用域的删除操作 故while循环头尾会增加一个作用域
    while 状态机的相关修改 加上了头尾节点  如下图
    while 和 do_while 都是 0 表示=第一个条件 1 则表示第二个条件
    DFA::run () 的整个逻辑 就是在执行一个链表 now 当前状态 now->next() 下一个状态
    continue 关键字的添加
    hl.g 中添加相关语法  handle.cc中相关责任链的实现 dfa.cc 的相关实现
    NopeDFANode 定位到相对应的作用

    break 和 continue 都为junpnode
    NopeDFANode 表示相对应continue跳的节点

    NopeDFANode 不在链表之内 在一个节点外边挂着(挂在 condition 节点处) 并且指向condition节点 
    continue 相关的节点 压入 continuePoint 相关的栈里 for循环连 do_node 节点


函数调用相关的语法构造

两个地方可以获得代码逻辑 就是代码的执行
haizei_runtime.cc 中 DFA program 和 program.run() 函数的执行
第二种是 RunTimeEnv::GetValue  获得相对应的值
函数的执行 更像是 状态机的表示 

函数的小于号的默认实现 抛出异常
FunctionValue  私有方法 为 convert zuanghui
Function 具体实现就是 function作为根节点 子树分别是 ID param block 
第三个节点为afa 首先转换 为相对应的dfa
第二种情况就是把 param 的子节点存起来 
convert constructor 部分中 
添加对应的方法
再添加相对应的访问者方法
类中 相关的ture 代表的是函数中该函数完成了相关的定义 默认为true
IValue 的派生类增加了 还要增加相对应的访问者 Ivisitor
函数定义功能的实现 首先 dfa,h中定义相关的 节点类 
dfa.cc中 bulid 的实现  就是把deffunctionDFANode 的值 放到作用域中去
dfa.cc 中实现相关的构造函数 FunctionValue定义 中 有个name方法为读取函数名字的方法

运行到相关节点就会把相关作用域的值 FunctionValue 存储到相关的作用域中去
责任链中 有function_call的相关调用
关于函数的调用参数的问题 就是构造一个新的作用域重新进行参数的赋值操作
func_call当前作用域 存储在this->p 中
首先提取出相对应的名字
函数的运行: func->run(p) 新方法 默认实现为抛出相对应的异常信息;
参数个数不对 会报出相关的错误
再进行相关值的赋值操作 
ReturnValueName 预存了相应的字符串
把return 进行相关的赋值操作 
再调用当前作用域的run方法
完成相关return的值的获取
最后完成作用域的销毁

return 后边接的 表达式 
作用是 跳转到某个作用域

return 相关的 状态机的构造
Function 系列的相关的思维逻辑
Function ASTree 和 DFA 两个参数 第一个为相对应的语法树 第二个是状态机
语法树初始化相对应的 func_name 和 param数组
return point 相关的栈的定义 
FUNC_CALL 中相对应的代码逻辑
dynamic_cast 为类型转换的函数

ReturnDFANode 方法先把其返回值计算出来 存入ReturnValueName 中 (匿名变量) 返回到作用域
这里是显示调用

增加一个红色的作用域 使的上下为两个区域 以至于 下边定义的函数 上边不能进行访问

在函数中增加了一个定义时的 作用域 p为执行时的作用域

return 节点 也是junpDFANode

